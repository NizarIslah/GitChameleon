{"python_version": "3.10", "library": "mitmproxy", "version": "7.0.0", "extra_dependencies": [], "problem": "Using mitmproxy\u2019s connection API, create a Python class named ConnectionLogger that implements a server connected event hook. When a server connection is established, your implementation should define a method that is automatically called with a parameter named server_conn. This parameter represents the connection object, and your method must print the server\u2019s local address by accessing server_conn.sockname. The printed output should follow the exact format: Server connected with local address {server_conn.sockname}. You must not modify the provided start code, which already includes the definitions for DummyServerConn and an empty ConnectionLogger class. Instead, complete the solution by dynamically adding the required method in the solution() function.", "starting_code": "import contextlib\n\nclass DummyServerConn:\n    def __init__(self, sockname):\n        self.sockname = sockname\n\nclass ConnectionLogger:\n    pass\n        \n\ndef solution() -> None:\n    def ", "example_id": "218", "test": "    \nimport unittest\nimport io\n\nclass TestConnectionLogger(unittest.TestCase):\n    def test_server_connected(self):\n        # Update the ConnectionLogger class with the new method.\n        solution()\n        logger = ConnectionLogger()\n        dummy_conn = DummyServerConn(('127.0.0.1', 8080))\n        \n        output = io.StringIO()\n        with contextlib.redirect_stdout(output):\n            logger.server_connected(dummy_conn)\n        print(output.getvalue())\n        expect = \"('127.0.0.1', 8080)\"\n        \n        self.assertIn(expect, output.getvalue())\n        \nunittest.main()\n    \n", "solution": " server_connected(self, server_conn: DummyServerConn) -> None:\n        print(server_conn.sockname)\n\n    ConnectionLogger.server_connected = server_connected", "type_of_change": "argument change", "name_of_class_or_func": "server_connected\n", "additional_dependencies": "", "messages": [{"role": "system", "content": "You are a skilled Python programmer tasked with solving a coding problem. Your goal is to provide a clear, efficient, and correct solution that meets all the specified requirements.\n\nPlease provide your solution following these guidelines:\n\n1. Use the required library in your solution.\n2. Incorporate the provided starter code correctly.\n3. Write your solution in Python.\n4. Format your solution within a markdown code block.\n5. Ensure your code is clean and efficient.\n6. Output only the code block and nothing else. Do not add any in-line comments, documentations, references or usage examples.\n7. Make sure your code is executable in a non-interactive environment. For example, do not write code which requires building a Django project or deploying a web-app.\n\nExample output format:\n\n```python\n# [Your code here, incorporating the starter code]\n```\n\nAfter writing your solution, please review it to ensure all requirements are met and the code is correct and efficient.\n\nHere are the key elements for this task: "}, {"role": "user", "content": "1. Required Library:\n<library>\nmitmproxy==7.0.0\n</library>\n\n2. Python version:\n<python>\n3.10\n</python>\n\n2. Coding Problem:\n<coding_problem>\nUsing mitmproxy\u2019s connection API, create a Python class named ConnectionLogger that implements a server connected event hook. When a server connection is established, your implementation should define a method that is automatically called with a parameter named server_conn. This parameter represents the connection object, and your method must print the server\u2019s local address by accessing server_conn.sockname. The printed output should follow the exact format: Server connected with local address {server_conn.sockname}. You must not modify the provided start code, which already includes the definitions for DummyServerConn and an empty ConnectionLogger class. Instead, complete the solution by dynamically adding the required method in the solution() function.\n</coding_problem>\n\n3. Starter Code:\n<starter_code>\nimport contextlib\n\nclass DummyServerConn:\n    def __init__(self, sockname):\n        self.sockname = sockname\n\nclass ConnectionLogger:\n    pass\n        \n\ndef solution() -> None:\n    def \n</starter_code>"}], "cot_messages": [{"role": "system", "content": "You are a skilled Python programmer tasked with solving a coding problem. Your goal is to provide a clear, efficient, and correct solution that meets all the specified requirements.\n\nFirst, let's think step-by-step. Then, please provide your solution following these guidelines:\n\n1. Use the required library in your solution.\n2. Incorporate the provided starter code correctly.\n3. Write your solution in Python.\n4. Format your solution within a markdown code block.\n5. Ensure your code is clean and efficient.\n6. Output only the code block and nothing else. Do not add any in-line comments, documentations, references or usage examples.\n7. Make sure your code is executable in a non-interactive environment. For example, do not write code which requires building a Django project or deploying a web-app.\n\nExample output format:\n\n```python\n# [Your code here, incorporating the starter code]\n```\n\nAfter writing your solution, please review it to ensure all requirements are met and the code is correct and efficient.\n\nHere are the key elements for this task: "}, {"role": "user", "content": "1. Required Library:\n<library>\nmitmproxy==7.0.0\n</library>\n\n2. Python version:\n<python>\n3.10\n</python>\n\n2. Coding Problem:\n<coding_problem>\nUsing mitmproxy\u2019s connection API, create a Python class named ConnectionLogger that implements a server connected event hook. When a server connection is established, your implementation should define a method that is automatically called with a parameter named server_conn. This parameter represents the connection object, and your method must print the server\u2019s local address by accessing server_conn.sockname. The printed output should follow the exact format: Server connected with local address {server_conn.sockname}. You must not modify the provided start code, which already includes the definitions for DummyServerConn and an empty ConnectionLogger class. Instead, complete the solution by dynamically adding the required method in the solution() function.\n</coding_problem>\n\n3. Starter Code:\n<starter_code>\nimport contextlib\n\nclass DummyServerConn:\n    def __init__(self, sockname):\n        self.sockname = sockname\n\nclass ConnectionLogger:\n    pass\n        \n\ndef solution() -> None:\n    def \n</starter_code>"}], "docs": ["https://docs.mitmproxy.org/stable/api/events.html"], "functional": 1, "webdev": 1}
